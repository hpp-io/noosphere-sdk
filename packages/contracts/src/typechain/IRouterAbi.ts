/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
  TypedContractMethod,
} from "./common";

export type ComputeSubscriptionStruct = {
  routeId: BytesLike;
  containerId: BytesLike;
  feeAmount: BigNumberish;
  client: AddressLike;
  activeAt: BigNumberish;
  intervalSeconds: BigNumberish;
  maxExecutions: BigNumberish;
  wallet: AddressLike;
  feeToken: AddressLike;
  verifier: AddressLike;
  redundancy: BigNumberish;
  useDeliveryInbox: boolean;
};

export type ComputeSubscriptionStructOutput = [
  routeId: string,
  containerId: string,
  feeAmount: bigint,
  client: string,
  activeAt: bigint,
  intervalSeconds: bigint,
  maxExecutions: bigint,
  wallet: string,
  feeToken: string,
  verifier: string,
  redundancy: bigint,
  useDeliveryInbox: boolean
] & {
  routeId: string;
  containerId: string;
  feeAmount: bigint;
  client: string;
  activeAt: bigint;
  intervalSeconds: bigint;
  maxExecutions: bigint;
  wallet: string;
  feeToken: string;
  verifier: string;
  redundancy: bigint;
  useDeliveryInbox: boolean;
};

export type PaymentStruct = {
  recipient: AddressLike;
  feeToken: AddressLike;
  feeAmount: BigNumberish;
};

export type PaymentStructOutput = [
  recipient: string,
  feeToken: string,
  feeAmount: bigint
] & { recipient: string; feeToken: string; feeAmount: bigint };

export type CommitmentStruct = {
  requestId: BytesLike;
  subscriptionId: BigNumberish;
  containerId: BytesLike;
  interval: BigNumberish;
  useDeliveryInbox: boolean;
  redundancy: BigNumberish;
  walletAddress: AddressLike;
  feeAmount: BigNumberish;
  feeToken: AddressLike;
  verifier: AddressLike;
  coordinator: AddressLike;
};

export type CommitmentStructOutput = [
  requestId: string,
  subscriptionId: bigint,
  containerId: string,
  interval: bigint,
  useDeliveryInbox: boolean,
  redundancy: bigint,
  walletAddress: string,
  feeAmount: bigint,
  feeToken: string,
  verifier: string,
  coordinator: string
] & {
  requestId: string;
  subscriptionId: bigint;
  containerId: string;
  interval: bigint;
  useDeliveryInbox: boolean;
  redundancy: bigint;
  walletAddress: string;
  feeAmount: bigint;
  feeToken: string;
  verifier: string;
  coordinator: string;
};

export type ProofVerificationRequestStruct = {
  subscriptionId: BigNumberish;
  interval: BigNumberish;
  submitterAddress: AddressLike;
  submitterWallet: AddressLike;
  escrowedAmount: BigNumberish;
  escrowToken: AddressLike;
  slashAmount: BigNumberish;
  expiry: BigNumberish;
};

export type ProofVerificationRequestStructOutput = [
  subscriptionId: bigint,
  interval: bigint,
  submitterAddress: string,
  submitterWallet: string,
  escrowedAmount: bigint,
  escrowToken: string,
  slashAmount: bigint,
  expiry: bigint
] & {
  subscriptionId: bigint;
  interval: bigint;
  submitterAddress: string;
  submitterWallet: string;
  escrowedAmount: bigint;
  escrowToken: string;
  slashAmount: bigint;
  expiry: bigint;
};

export interface IRouterAbiInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "createSubscriptionDelegatee"
      | "fulfill"
      | "getContractById"
      | "getLastSubscriptionId"
      | "getProposedContractById"
      | "getWalletFactory"
      | "hasSubscriptionNextInterval"
      | "isValidWallet"
      | "lockForVerification"
      | "pause"
      | "payFromCoordinator"
      | "prepareNodeVerification"
      | "proposeContractsUpdate"
      | "sendRequest"
      | "timeoutRequest"
      | "unlockForVerification"
      | "unpause"
      | "updateContracts"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "createSubscriptionDelegatee",
    values: [BigNumberish, BigNumberish, ComputeSubscriptionStruct, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fulfill",
    values: [
      BytesLike,
      BytesLike,
      BytesLike,
      BigNumberish,
      AddressLike,
      PaymentStruct[],
      CommitmentStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getContractById",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getLastSubscriptionId",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getProposedContractById",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getWalletFactory",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "hasSubscriptionNextInterval",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "isValidWallet",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "lockForVerification",
    values: [ProofVerificationRequestStruct, BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "pause", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "payFromCoordinator",
    values: [BigNumberish, AddressLike, AddressLike, PaymentStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "prepareNodeVerification",
    values: [BigNumberish, BigNumberish, AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "proposeContractsUpdate",
    values: [BytesLike[], AddressLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "sendRequest",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "timeoutRequest",
    values: [BytesLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "unlockForVerification",
    values: [ProofVerificationRequestStruct]
  ): string;
  encodeFunctionData(functionFragment: "unpause", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "updateContracts",
    values?: undefined
  ): string;

  decodeFunctionResult(
    functionFragment: "createSubscriptionDelegatee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "fulfill", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getContractById",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLastSubscriptionId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getProposedContractById",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getWalletFactory",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "hasSubscriptionNextInterval",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isValidWallet",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "lockForVerification",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "pause", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "payFromCoordinator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "prepareNodeVerification",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proposeContractsUpdate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "sendRequest",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "timeoutRequest",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "unlockForVerification",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "unpause", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "updateContracts",
    data: BytesLike
  ): Result;
}

export interface IRouterAbi extends BaseContract {
  connect(runner?: ContractRunner | null): IRouterAbi;
  waitForDeployment(): Promise<this>;

  interface: IRouterAbiInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  createSubscriptionDelegatee: TypedContractMethod<
    [
      nonce: BigNumberish,
      expiry: BigNumberish,
      sub: ComputeSubscriptionStruct,
      signature: BytesLike
    ],
    [bigint],
    "nonpayable"
  >;

  fulfill: TypedContractMethod<
    [
      input: BytesLike,
      output: BytesLike,
      proof: BytesLike,
      numRedundantDeliveries: BigNumberish,
      nodeWallet: AddressLike,
      payments: PaymentStruct[],
      commitment: CommitmentStruct
    ],
    [bigint],
    "nonpayable"
  >;

  getContractById: TypedContractMethod<[id: BytesLike], [string], "view">;

  getLastSubscriptionId: TypedContractMethod<[], [bigint], "view">;

  getProposedContractById: TypedContractMethod<
    [id: BytesLike],
    [string],
    "view"
  >;

  getWalletFactory: TypedContractMethod<[], [string], "view">;

  hasSubscriptionNextInterval: TypedContractMethod<
    [subscriptionId: BigNumberish, currentInterval: BigNumberish],
    [boolean],
    "view"
  >;

  isValidWallet: TypedContractMethod<
    [walletAddr: AddressLike],
    [boolean],
    "view"
  >;

  lockForVerification: TypedContractMethod<
    [proofRequest: ProofVerificationRequestStruct, commitmentHash: BytesLike],
    [void],
    "nonpayable"
  >;

  pause: TypedContractMethod<[], [void], "nonpayable">;

  payFromCoordinator: TypedContractMethod<
    [
      subscriptionId: BigNumberish,
      spenderWallet: AddressLike,
      spenderAddress: AddressLike,
      payments: PaymentStruct[]
    ],
    [void],
    "nonpayable"
  >;

  prepareNodeVerification: TypedContractMethod<
    [
      subscriptionId: BigNumberish,
      nextInterval: BigNumberish,
      nodeWallet: AddressLike,
      token: AddressLike,
      amount: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  proposeContractsUpdate: TypedContractMethod<
    [proposalSetIds: BytesLike[], proposalSetAddresses: AddressLike[]],
    [void],
    "nonpayable"
  >;

  sendRequest: TypedContractMethod<
    [subscriptionId: BigNumberish, interval: BigNumberish],
    [
      [string, CommitmentStructOutput] & {
        requestKey: string;
        commitment: CommitmentStructOutput;
      }
    ],
    "nonpayable"
  >;

  timeoutRequest: TypedContractMethod<
    [
      requestId: BytesLike,
      subscriptionId: BigNumberish,
      interval: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  unlockForVerification: TypedContractMethod<
    [proofRequest: ProofVerificationRequestStruct],
    [void],
    "nonpayable"
  >;

  unpause: TypedContractMethod<[], [void], "nonpayable">;

  updateContracts: TypedContractMethod<[], [void], "nonpayable">;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "createSubscriptionDelegatee"
  ): TypedContractMethod<
    [
      nonce: BigNumberish,
      expiry: BigNumberish,
      sub: ComputeSubscriptionStruct,
      signature: BytesLike
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fulfill"
  ): TypedContractMethod<
    [
      input: BytesLike,
      output: BytesLike,
      proof: BytesLike,
      numRedundantDeliveries: BigNumberish,
      nodeWallet: AddressLike,
      payments: PaymentStruct[],
      commitment: CommitmentStruct
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getContractById"
  ): TypedContractMethod<[id: BytesLike], [string], "view">;
  getFunction(
    nameOrSignature: "getLastSubscriptionId"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "getProposedContractById"
  ): TypedContractMethod<[id: BytesLike], [string], "view">;
  getFunction(
    nameOrSignature: "getWalletFactory"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "hasSubscriptionNextInterval"
  ): TypedContractMethod<
    [subscriptionId: BigNumberish, currentInterval: BigNumberish],
    [boolean],
    "view"
  >;
  getFunction(
    nameOrSignature: "isValidWallet"
  ): TypedContractMethod<[walletAddr: AddressLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "lockForVerification"
  ): TypedContractMethod<
    [proofRequest: ProofVerificationRequestStruct, commitmentHash: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "pause"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "payFromCoordinator"
  ): TypedContractMethod<
    [
      subscriptionId: BigNumberish,
      spenderWallet: AddressLike,
      spenderAddress: AddressLike,
      payments: PaymentStruct[]
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "prepareNodeVerification"
  ): TypedContractMethod<
    [
      subscriptionId: BigNumberish,
      nextInterval: BigNumberish,
      nodeWallet: AddressLike,
      token: AddressLike,
      amount: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "proposeContractsUpdate"
  ): TypedContractMethod<
    [proposalSetIds: BytesLike[], proposalSetAddresses: AddressLike[]],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "sendRequest"
  ): TypedContractMethod<
    [subscriptionId: BigNumberish, interval: BigNumberish],
    [
      [string, CommitmentStructOutput] & {
        requestKey: string;
        commitment: CommitmentStructOutput;
      }
    ],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "timeoutRequest"
  ): TypedContractMethod<
    [
      requestId: BytesLike,
      subscriptionId: BigNumberish,
      interval: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "unlockForVerification"
  ): TypedContractMethod<
    [proofRequest: ProofVerificationRequestStruct],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "unpause"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "updateContracts"
  ): TypedContractMethod<[], [void], "nonpayable">;

  filters: {};
}
