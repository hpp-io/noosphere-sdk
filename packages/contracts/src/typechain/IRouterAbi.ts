/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
  TypedContractMethod,
} from "./common";

export type PayloadDataStruct = { contentHash: BytesLike; uri: BytesLike };

export type PayloadDataStructOutput = [contentHash: string, uri: string] & {
  contentHash: string;
  uri: string;
};

export type PaymentStruct = {
  recipient: AddressLike;
  feeToken: AddressLike;
  feeAmount: BigNumberish;
};

export type PaymentStructOutput = [
  recipient: string,
  feeToken: string,
  feeAmount: bigint
] & { recipient: string; feeToken: string; feeAmount: bigint };

export type CommitmentStruct = {
  requestId: BytesLike;
  subscriptionId: BigNumberish;
  containerId: BytesLike;
  interval: BigNumberish;
  useDeliveryInbox: boolean;
  walletAddress: AddressLike;
  feeAmount: BigNumberish;
  feeToken: AddressLike;
  verifier: AddressLike;
  coordinator: AddressLike;
  verifierFee: BigNumberish;
};

export type CommitmentStructOutput = [
  requestId: string,
  subscriptionId: bigint,
  containerId: string,
  interval: bigint,
  useDeliveryInbox: boolean,
  walletAddress: string,
  feeAmount: bigint,
  feeToken: string,
  verifier: string,
  coordinator: string,
  verifierFee: bigint
] & {
  requestId: string;
  subscriptionId: bigint;
  containerId: string;
  interval: bigint;
  useDeliveryInbox: boolean;
  walletAddress: string;
  feeAmount: bigint;
  feeToken: string;
  verifier: string;
  coordinator: string;
  verifierFee: bigint;
};

export type ProofVerificationRequestStruct = {
  subscriptionId: BigNumberish;
  interval: BigNumberish;
  submitterAddress: AddressLike;
  submitterWallet: AddressLike;
  escrowedAmount: BigNumberish;
  escrowToken: AddressLike;
  slashAmount: BigNumberish;
  expiry: BigNumberish;
};

export type ProofVerificationRequestStructOutput = [
  subscriptionId: bigint,
  interval: bigint,
  submitterAddress: string,
  submitterWallet: string,
  escrowedAmount: bigint,
  escrowToken: string,
  slashAmount: bigint,
  expiry: bigint
] & {
  subscriptionId: bigint;
  interval: bigint;
  submitterAddress: string;
  submitterWallet: string;
  escrowedAmount: bigint;
  escrowToken: string;
  slashAmount: bigint;
  expiry: bigint;
};

export interface IRouterAbiInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "areValidWallets"
      | "fulfill"
      | "getContractById"
      | "getIntervalAndValidateWallets"
      | "getLastSubscriptionId"
      | "getProposedContractById"
      | "getWalletFactory"
      | "hasSubscriptionNextInterval"
      | "isValidWallet"
      | "lockForVerification"
      | "pause"
      | "payFromCoordinator"
      | "prepareNodeVerification"
      | "proposeContractsUpdate"
      | "sendRequest"
      | "timeoutRequest"
      | "unlockAndPayForVerification"
      | "unlockForVerification"
      | "unpause"
      | "updateContracts"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "areValidWallets",
    values: [AddressLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "fulfill",
    values: [
      PayloadDataStruct,
      PayloadDataStruct,
      PayloadDataStruct,
      AddressLike,
      PaymentStruct[],
      CommitmentStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getContractById",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getIntervalAndValidateWallets",
    values: [BigNumberish, AddressLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "getLastSubscriptionId",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getProposedContractById",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getWalletFactory",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "hasSubscriptionNextInterval",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "isValidWallet",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "lockForVerification",
    values: [ProofVerificationRequestStruct, BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "pause", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "payFromCoordinator",
    values: [BigNumberish, AddressLike, AddressLike, PaymentStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "prepareNodeVerification",
    values: [BigNumberish, BigNumberish, AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "proposeContractsUpdate",
    values: [BytesLike[], AddressLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "sendRequest",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "timeoutRequest",
    values: [BytesLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "unlockAndPayForVerification",
    values: [
      ProofVerificationRequestStruct,
      AddressLike,
      AddressLike,
      PaymentStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "unlockForVerification",
    values: [ProofVerificationRequestStruct]
  ): string;
  encodeFunctionData(functionFragment: "unpause", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "updateContracts",
    values?: undefined
  ): string;

  decodeFunctionResult(
    functionFragment: "areValidWallets",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "fulfill", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getContractById",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getIntervalAndValidateWallets",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLastSubscriptionId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getProposedContractById",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getWalletFactory",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "hasSubscriptionNextInterval",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isValidWallet",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "lockForVerification",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "pause", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "payFromCoordinator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "prepareNodeVerification",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proposeContractsUpdate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "sendRequest",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "timeoutRequest",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "unlockAndPayForVerification",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "unlockForVerification",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "unpause", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "updateContracts",
    data: BytesLike
  ): Result;
}

export interface IRouterAbi extends BaseContract {
  connect(runner?: ContractRunner | null): IRouterAbi;
  waitForDeployment(): Promise<this>;

  interface: IRouterAbiInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  areValidWallets: TypedContractMethod<
    [walletAddrs: AddressLike[]],
    [boolean],
    "view"
  >;

  fulfill: TypedContractMethod<
    [
      input: PayloadDataStruct,
      output: PayloadDataStruct,
      proof: PayloadDataStruct,
      nodeWallet: AddressLike,
      payments: PaymentStruct[],
      commitment: CommitmentStruct
    ],
    [bigint],
    "nonpayable"
  >;

  getContractById: TypedContractMethod<[id: BytesLike], [string], "view">;

  getIntervalAndValidateWallets: TypedContractMethod<
    [subscriptionId: BigNumberish, walletAddrs: AddressLike[]],
    [[bigint, boolean] & { interval: bigint; allWalletsValid: boolean }],
    "view"
  >;

  getLastSubscriptionId: TypedContractMethod<[], [bigint], "view">;

  getProposedContractById: TypedContractMethod<
    [id: BytesLike],
    [string],
    "view"
  >;

  getWalletFactory: TypedContractMethod<[], [string], "view">;

  hasSubscriptionNextInterval: TypedContractMethod<
    [subscriptionId: BigNumberish, currentInterval: BigNumberish],
    [boolean],
    "view"
  >;

  isValidWallet: TypedContractMethod<
    [walletAddr: AddressLike],
    [boolean],
    "view"
  >;

  lockForVerification: TypedContractMethod<
    [proofRequest: ProofVerificationRequestStruct, commitmentHash: BytesLike],
    [void],
    "nonpayable"
  >;

  pause: TypedContractMethod<[], [void], "nonpayable">;

  payFromCoordinator: TypedContractMethod<
    [
      subscriptionId: BigNumberish,
      spenderWallet: AddressLike,
      spenderAddress: AddressLike,
      payments: PaymentStruct[]
    ],
    [void],
    "nonpayable"
  >;

  prepareNodeVerification: TypedContractMethod<
    [
      subscriptionId: BigNumberish,
      nextInterval: BigNumberish,
      nodeWallet: AddressLike,
      token: AddressLike,
      amount: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  proposeContractsUpdate: TypedContractMethod<
    [proposalSetIds: BytesLike[], proposalSetAddresses: AddressLike[]],
    [void],
    "nonpayable"
  >;

  sendRequest: TypedContractMethod<
    [subscriptionId: BigNumberish, interval: BigNumberish],
    [
      [string, CommitmentStructOutput] & {
        requestKey: string;
        commitment: CommitmentStructOutput;
      }
    ],
    "nonpayable"
  >;

  timeoutRequest: TypedContractMethod<
    [
      requestId: BytesLike,
      subscriptionId: BigNumberish,
      interval: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  unlockAndPayForVerification: TypedContractMethod<
    [
      proofRequest: ProofVerificationRequestStruct,
      spenderWallet: AddressLike,
      spenderAddress: AddressLike,
      payments: PaymentStruct[]
    ],
    [void],
    "nonpayable"
  >;

  unlockForVerification: TypedContractMethod<
    [proofRequest: ProofVerificationRequestStruct],
    [void],
    "nonpayable"
  >;

  unpause: TypedContractMethod<[], [void], "nonpayable">;

  updateContracts: TypedContractMethod<[], [void], "nonpayable">;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "areValidWallets"
  ): TypedContractMethod<[walletAddrs: AddressLike[]], [boolean], "view">;
  getFunction(
    nameOrSignature: "fulfill"
  ): TypedContractMethod<
    [
      input: PayloadDataStruct,
      output: PayloadDataStruct,
      proof: PayloadDataStruct,
      nodeWallet: AddressLike,
      payments: PaymentStruct[],
      commitment: CommitmentStruct
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getContractById"
  ): TypedContractMethod<[id: BytesLike], [string], "view">;
  getFunction(
    nameOrSignature: "getIntervalAndValidateWallets"
  ): TypedContractMethod<
    [subscriptionId: BigNumberish, walletAddrs: AddressLike[]],
    [[bigint, boolean] & { interval: bigint; allWalletsValid: boolean }],
    "view"
  >;
  getFunction(
    nameOrSignature: "getLastSubscriptionId"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "getProposedContractById"
  ): TypedContractMethod<[id: BytesLike], [string], "view">;
  getFunction(
    nameOrSignature: "getWalletFactory"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "hasSubscriptionNextInterval"
  ): TypedContractMethod<
    [subscriptionId: BigNumberish, currentInterval: BigNumberish],
    [boolean],
    "view"
  >;
  getFunction(
    nameOrSignature: "isValidWallet"
  ): TypedContractMethod<[walletAddr: AddressLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "lockForVerification"
  ): TypedContractMethod<
    [proofRequest: ProofVerificationRequestStruct, commitmentHash: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "pause"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "payFromCoordinator"
  ): TypedContractMethod<
    [
      subscriptionId: BigNumberish,
      spenderWallet: AddressLike,
      spenderAddress: AddressLike,
      payments: PaymentStruct[]
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "prepareNodeVerification"
  ): TypedContractMethod<
    [
      subscriptionId: BigNumberish,
      nextInterval: BigNumberish,
      nodeWallet: AddressLike,
      token: AddressLike,
      amount: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "proposeContractsUpdate"
  ): TypedContractMethod<
    [proposalSetIds: BytesLike[], proposalSetAddresses: AddressLike[]],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "sendRequest"
  ): TypedContractMethod<
    [subscriptionId: BigNumberish, interval: BigNumberish],
    [
      [string, CommitmentStructOutput] & {
        requestKey: string;
        commitment: CommitmentStructOutput;
      }
    ],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "timeoutRequest"
  ): TypedContractMethod<
    [
      requestId: BytesLike,
      subscriptionId: BigNumberish,
      interval: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "unlockAndPayForVerification"
  ): TypedContractMethod<
    [
      proofRequest: ProofVerificationRequestStruct,
      spenderWallet: AddressLike,
      spenderAddress: AddressLike,
      payments: PaymentStruct[]
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "unlockForVerification"
  ): TypedContractMethod<
    [proofRequest: ProofVerificationRequestStruct],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "unpause"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "updateContracts"
  ): TypedContractMethod<[], [void], "nonpayable">;

  filters: {};
}
